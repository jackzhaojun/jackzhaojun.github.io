---
        layout: page
---
###前言jquery@version v1.11.1
当我们需要绑定一个object对象到dom节点我们通常会用$(selector).data(key, object)这样的形式来存取数据，
但是为什么不用$(selector).attr(key, object)这样的形式呢？ 这是因为如果把一个object对象绑定到dom节点上在IE6,7下有内存泄露的风险。

###设计思路
通过阅读源码发现jQuery定义了一个cache对象来做这些节点数据的管理,每个dom节点会有一个guid来，用guid作为cache的key值来存取数据的。可以通过控制台jQuery.cache来打印查看数据节点信息。

###internalKey对应guid
有了cache对象后，如何能把数据和节点对应到一块呢？第一次使用$.data()方法的时候会有一个internalKey被当做当前节点的属性，
然后会有一个guid被赋予当前节点的internalKey属性以下是部分源码

    internalKey = jQuery.expando  //jQuery.expando是jQuery初始化生成的一个随机字符可通过控制台打印查看
    ...
    //试图通过elem[ internalKey ]来获取Id
    id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
    //没有找到id就生成一个ID elem[ internalKey ] = jQuery.guid++;
    if ( !id ) {
        //为每个dom节点的internalKey属性生成 一个guid
        if ( isNode ) {
            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
        } else {
            id = internalKey;
        }
    }

拿到id通过jQuery.cache.id就能映射到一个当前节点的唯一值了。 然后根据参数做存或者取得操作。

###存取值的内部实现细节
理解细节前，src/data.js文件中有几个重要的函数需要提前知道。

        //data函数绑定到jQuery原型上。
        jQuery.fn.extend({
                data: function (key, value) {
                        ....
                }
        });
        //数据存取的核心实现
        function internalData (elem, name, data, pvt) {
                ....
        }
        //获取当前节点内部数据data-*，处理后放到cache里
        function dataAttr( elem, key, data ) {
                ....
        }
        
先来看下data函数的内部实现,首先会拿到当前作用域对象的的第一个元素， 然后获取第一个元素的所有属性elem.attributes。接下来我们会对传入的参数进行判断做读的操作还是写的操作。

        jQuery.fn.extend({
        	data: function( key, value ) {
        		var i, name, data,
        		        //获取第一个元素的目的？ 当进行读操作的时候 我们只读第一个元素绑定的cache数据
        			elem = this[0],
        			attrs = elem && elem.attributes;
        
        		// Special expections of .data basically thwart jQuery.access,
        		// so implement the relevant behavior ourselves
        
        		// 提交判断1， 当没有传入任何值得时候 返回当前节点所有的数据。
        		if ( key === undefined ) {
        			if ( this.length ) {
        				data = jQuery.data( elem );
        
        				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
        					i = attrs.length;
        					while ( i-- ) {
        
        						// Support: IE11+
        						// The attrs elements can be null (#14894)
                                                        //IE11私有数据-ms-非data-
        						if ( attrs[ i ] ) {
        							name = attrs[ i ].name;
        							if ( name.indexOf( "data-" ) === 0 ) {
        								name = jQuery.camelCase( name.slice(5) );
        								dataAttr( elem, name, data[ name ] );
        							}
        						}
        					}
        					jQuery._data( elem, "parsedAttrs", true );
        				}
        			}
        
        			return data;
        		}
        
        		// 条件判断2 当key值为object的时候进行写的操作
        		if ( typeof key === "object" ) {
        			return this.each(function() {
        				jQuery.data( this, key );
        			});
        		}
        
                        //条件判断3 参数个数大于1的时候 做写的操作，小于1的时候做读的操作。做读操作的时候要注意下要先掉用dataAttr方法优先获取内部data-*数据
        		return arguments.length > 1 ?
        
        			// Sets one value
        			this.each(function() {
        				jQuery.data( this, key, value );
        			}) :
        
        			// Gets one value
        			// Try to fetch any internally stored data first
                                //首先尝试获取内部data-*数据
        			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
        	}
        
        });




        
        
